{"version":3,"sources":["../src/error.ts","../src/http.ts","../src/connection.ts","../src/encoding.ts","../src/main.ts"],"names":[],"mappings":"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","sourcesContent":["/** Metadata associated with a {@link YSweetError}. */\nexport type YSweetErrorPayload =\n  | { code: 'ServerRefused'; address: string; port: number; url: string }\n  | { code: 'ServerError'; status: number; message: string; url: string }\n  | { code: 'NoAuthProvided' }\n  | { code: 'InvalidAuthProvided' }\n  | { code: 'Unknown'; message: string }\n\n/** An error returned by the y-sweet SDK. */\nexport class YSweetError extends Error {\n  /**\n   * Create a new {@link YSweetError}.\n   *\n   * @param cause An object representing metadata associated with the error.\n   * @see {@link YSweetErrorPayload}\n   */\n  constructor(public cause: YSweetErrorPayload) {\n    super(YSweetError.getMessage(cause))\n    this.name = 'YSweetError'\n  }\n\n  /** Convert the message to an error string that can be displayed to the user.\n   *\n   * The error string can also be used with {@link YSweetError.fromMessage} to\n   * reconstruct the payload object, which is useful in the context of Next.js,\n   * which will only pass an error string from the server to the client.\n   *\n   * @param payload The payload object to convert to a string.\n   * @returns A string representation of the error.\n   */\n  static getMessage(payload: YSweetErrorPayload): string {\n    let message\n    if (payload.code === 'ServerRefused') {\n      message = `Server at ${payload.address}:${payload.port} refused connection. URL: ${payload.url}`\n    } else if (payload.code === 'ServerError') {\n      message = `Server responded with ${payload.status} ${payload.message}. URL: ${payload.url}`\n    } else if (payload.code === 'NoAuthProvided') {\n      message = 'No auth provided'\n    } else if (payload.code === 'InvalidAuthProvided') {\n      message = 'Invalid auth provided'\n    } else {\n      message = payload.message\n    }\n    return `${payload.code}: ${message}`\n  }\n\n  /**\n   * In development, next.js passes error objects to the client but strips out everything but the\n   * `message` field. This method allows us to reconstruct the original error object.\n   *\n   * @param messageString The error message string to reconstruct a payload from.\n   * @returns A {@link YSweetError} object.\n   * @see {@link https://nextjs.org/docs/app/api-reference/file-conventions/error#errormessage| Next.js docs}\n   */\n  static fromMessage(messageString: string): YSweetError {\n    let match = messageString.match(/^(.*?): (.*)$/)\n    if (!match) {\n      return new YSweetError({ code: 'Unknown', message: messageString })\n    }\n\n    let [, code, message] = match\n\n    if (code === 'ServerRefused') {\n      match = message.match(/^Server at (.*?):(\\d+) refused connection. URL: (.*)$/)\n      if (!match) {\n        return new YSweetError({ code: 'Unknown', message: messageString })\n      }\n\n      let [, address, port, url] = match\n      return new YSweetError({ code, address, port: parseInt(port), url })\n    }\n\n    if (code === 'ServerError') {\n      match = message.match(/^Server responded with (\\d+) (.*). URL: (.*)$/)\n      if (!match) {\n        return new YSweetError({ code: 'Unknown', message: messageString })\n      }\n\n      let [, status, statusText, url] = match\n      return new YSweetError({ code, status: parseInt(status), message: statusText, url })\n    }\n\n    if (code === 'NoAuthProvided') {\n      return new YSweetError({ code })\n    }\n\n    if (code === 'InvalidAuthProvided') {\n      return new YSweetError({ code })\n    }\n\n    return new YSweetError({ code: 'Unknown', message })\n  }\n}\n","import { YSweetError } from './error'\n\n/** A type that can be used as an HTTP request body.\n * If a `Uint8Array` is provided, the body is sent as a raw binary body\n * with the `Content-Type` header set to `application/octet-stream`.\n * Otherwise, the body is sent as a JSON body with the `Content-Type`\n * header set to `application/json`.\n */\nexport type BodyType = Record<string, any> | Uint8Array\n\nexport class HttpClient {\n  private token: string | null = null\n  private baseUrl: string\n\n  constructor(baseUrl: string, token: string | null) {\n    this.baseUrl = baseUrl\n    this.token = token\n  }\n\n  public async request(url: string, method: 'GET'): Promise<Response>\n  public async request(url: string, method: 'POST', body: BodyType): Promise<Response>\n\n  public async request(path: string, method: 'GET' | 'POST', body?: BodyType): Promise<Response> {\n    const headers = new Headers()\n    if (this.token) {\n      headers.set('Authorization', `Bearer ${this.token}`)\n    }\n\n    let rawBody: string | Uint8Array\n    if (body instanceof Uint8Array) {\n      headers.set('Content-Type', 'application/octet-stream')\n      rawBody = body\n    } else if (body) {\n      headers.set('Content-Type', 'application/json')\n      rawBody = JSON.stringify(body)\n    }\n\n    // NOTE: In some environments (e.g. NextJS), responses are cached by default. Disabling\n    // the cache using `cache: 'no-store'` causes fetch() to error in other environments\n    // (e.g. Cloudflare Workers). To work around this, we simply add a cache-busting query\n    // param.\n    const cacheBust = generateRandomString()\n    let url = `${this.baseUrl}/${path}?z=${cacheBust}`\n    let result: Response\n    try {\n      result = await fetch(url, {\n        method,\n        body: rawBody!,\n        headers,\n      })\n    } catch (error: any) {\n      if (error.cause?.code === 'ECONNREFUSED') {\n        let { address, port } = error.cause\n        throw new YSweetError({ code: 'ServerRefused', address, port, url })\n      } else {\n        throw new YSweetError({ code: 'Unknown', message: error.toString() })\n      }\n    }\n\n    if (!result.ok) {\n      if (result.status === 401) {\n        if (this.token) {\n          throw new YSweetError({ code: 'InvalidAuthProvided' })\n        } else {\n          throw new YSweetError({ code: 'NoAuthProvided' })\n        }\n      }\n\n      throw new YSweetError({\n        code: 'ServerError',\n        status: result.status,\n        message: result.statusText,\n        url,\n      })\n    }\n\n    return result\n  }\n}\n\nfunction generateRandomString(): string {\n  return Math.random().toString(36).substring(2)\n}\n","import { HttpClient } from './http'\nimport { ClientToken } from './types'\n\nexport class DocConnection {\n  private client: HttpClient\n  private docId: string\n\n  constructor(clientToken: ClientToken) {\n    // Strip trailing slash from baseUrl\n    let baseUrl = clientToken.baseUrl.replace(/\\/$/, '')\n    this.client = new HttpClient(baseUrl, clientToken.token ?? null)\n    this.docId = clientToken.docId\n  }\n\n  /**\n   * Returns an entire document, represented as a Yjs update byte string.\n   *\n   * This can be turned back into a Yjs document as follows:\n   *\n   * ```typescript\n   * import * as Y from 'yjs'\n   *\n   * let update = await manager.getDocAsUpdate(docId)\n   * let doc = new Y.Doc()\n   * doc.transact(() => {\n   *  Y.applyUpdate(doc, update)\n   * })\n   * ```\n   *\n   * @returns\n   */\n  public async getAsUpdate(): Promise<Uint8Array> {\n    const result = await this.client.request(`as-update`, 'GET')\n    if (!result.ok) {\n      throw new Error(`Failed to get doc ${this.docId}: ${result.status} ${result.statusText}`)\n    }\n\n    let buffer = await result.arrayBuffer()\n    return new Uint8Array(buffer)\n  }\n\n  /**\n   * Updates a document with the given Yjs update byte string.\n   *\n   * This can be generated from a Yjs document as follows:\n   *\n   * ```typescript\n   * import * as Y from 'yjs'\n   *\n   * let doc = new Y.Doc()\n   * // Modify the document...\n   * let update = Y.encodeStateAsUpdate(doc)\n   * await manager.updateDoc(docId, update)\n   * ```\n   *\n   * @param update\n   */\n  public async updateDoc(update: Uint8Array): Promise<void> {\n    const result = await this.client.request(`update`, 'POST', update)\n\n    if (!result.ok) {\n      throw new Error(`Failed to update doc ${this.docId}: ${result.status} ${result.statusText}`)\n    }\n  }\n}\n","import { ClientToken } from './types'\n\nfunction stringToBase64(input: string) {\n  if (typeof window !== 'undefined' && window.btoa) {\n    // Browser\n    return window.btoa(input)\n  } else if (typeof Buffer !== 'undefined') {\n    // Node.js\n    return Buffer.from(input).toString('base64')\n  } else {\n    throw new Error('Unable to encode to Base64')\n  }\n}\n\nfunction base64ToString(input: string) {\n  if (typeof window !== 'undefined' && window.atob) {\n    // Browser\n    return window.atob(input)\n  } else if (typeof Buffer !== 'undefined') {\n    // Node.js\n    return Buffer.from(input, 'base64').toString()\n  } else {\n    throw new Error('Unable to decode from Base64')\n  }\n}\n\nexport function encodeClientToken(token: ClientToken): string {\n  const jsonString = JSON.stringify(token)\n  let base64 = stringToBase64(jsonString)\n  base64 = base64.replace('+', '-').replace('/', '_').replace(/=+$/, '')\n  return base64\n}\n\nexport function decodeClientToken(token: string): ClientToken {\n  let base64 = token.replace('-', '+').replace('_', '/')\n  while (base64.length % 4) {\n    base64 += '='\n  }\n  const jsonString = base64ToString(base64)\n  return JSON.parse(jsonString)\n}\n","import { DocConnection } from './connection'\nexport { DocConnection } from './connection'\nimport { HttpClient } from './http'\nimport type { DocCreationResult, ClientToken, CheckStoreResult, AuthDocRequest } from './types'\nexport type { DocCreationResult, ClientToken, CheckStoreResult } from './types'\nexport { type YSweetErrorPayload, YSweetError } from './error'\nexport { encodeClientToken, decodeClientToken } from './encoding'\n\n/** Represents an interface to a y-sweet document management endpoint. */\nexport class DocumentManager {\n  /** Wraps a fetch request with authorization and error handling. */\n  private client: HttpClient\n\n  /**\n   * Create a new {@link DocumentManager}.\n   *\n   * @param serverToken A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.\n   */\n  constructor(connectionString: string) {\n    const parsedUrl = new URL(connectionString)\n\n    let token = null\n    if (parsedUrl.username) {\n      // Decode the token from the URL.\n      token = decodeURIComponent(parsedUrl.username)\n    }\n\n    let protocol = parsedUrl.protocol\n    if (protocol === 'ys:') {\n      protocol = 'http:'\n    } else if (protocol === 'yss:') {\n      protocol = 'https:'\n    }\n\n    // NB: we manually construct the string here because node's URL implementation does\n    //     not handle changing the protocol of a URL well.\n    //     see: https://nodejs.org/api/url.html#urlprotocol\n    const url = `${protocol}//${parsedUrl.host}${parsedUrl.pathname}`\n    let baseUrl = url.replace(/\\/$/, '') // Remove trailing slash\n\n    this.client = new HttpClient(baseUrl, token)\n  }\n\n  public async checkStore(): Promise<CheckStoreResult> {\n    return await (await this.client.request('check_store', 'POST', {})).json()\n  }\n\n  /**\n   * Creates a new document on the y-sweet server given an optional docId. If a document with given\n   * ID already exists, this is a no-op.\n   *\n   * @param docId The ID of the document to be created. If not provided, a random ID will be generated.\n   * @returns A {@link DocCreationResult} object containing the ID of the created document.\n   */\n  public async createDoc(docId?: string): Promise<DocCreationResult> {\n    const body = docId ? { docId } : {}\n    const result = await this.client.request('doc/new', 'POST', body)\n    if (!result.ok) {\n      throw new Error(`Failed to create doc: ${result.status} ${result.statusText}`)\n    }\n    const responseBody = (await result.json()) as DocCreationResult\n    return responseBody\n  }\n\n  /**\n   * Get a client token for the given document.\n   *\n   * If you are using authorization, this is expected to be called from your server\n   * after a user has authenticated. The returned token should then be passed to the\n   * client.\n   *\n   * @param docId The ID of the document to get a token for.\n   * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.\n   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n   */\n  public async getClientToken(\n    docId: string | DocCreationResult,\n    authDocRequest?: AuthDocRequest,\n  ): Promise<ClientToken> {\n    if (typeof docId !== 'string') {\n      docId = docId.docId\n    }\n\n    const result = await this.client.request(`doc/${docId}/auth`, 'POST', authDocRequest ?? {})\n    if (!result.ok) {\n      throw new Error(`Failed to auth doc ${docId}: ${result.status} ${result.statusText}`)\n    }\n    const responseBody = (await result.json()) as ClientToken\n    return responseBody\n  }\n\n  /**\n   * A convenience wrapper around {@link DocumentManager.createDoc} and {@link DocumentManager.getClientToken} for\n   * getting a client token for a document. If a docId is provided, ensures that a document exists with that ID or\n   * that one is created. If no docId is provided, a new document is created with a random ID.\n   *\n   * @param docId The ID of the document to get or create. If not provided, a new document with a random ID will be created.\n   * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.\n   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n   */\n  public async getOrCreateDocAndToken(\n    docId?: string,\n    authDocRequest?: AuthDocRequest,\n  ): Promise<ClientToken> {\n    const result = await this.createDoc(docId)\n    return await this.getClientToken(result, authDocRequest)\n  }\n\n  /**\n   * Returns an entire document, represented as a Yjs update byte string.\n   *\n   * @param docId The ID of the document to get.\n   * @returns The document as a Yjs update byte string\n   */\n  public async getDocAsUpdate(docId: string): Promise<Uint8Array> {\n    const connection = await this.getDocConnection(docId)\n    return await connection.getAsUpdate()\n  }\n\n  /**\n   * Updates a document with the given Yjs update byte string.\n   *\n   * @param docId The ID of the document to update.\n   * @param update The Yjs update byte string to apply to the document.\n   */\n  public async updateDoc(docId: string, update: Uint8Array): Promise<void> {\n    const connection = await this.getDocConnection(docId)\n    return await connection.updateDoc(update)\n  }\n\n  public async getDocConnection(\n    docId: string | DocCreationResult,\n    authDocRequest?: AuthDocRequest,\n  ): Promise<DocConnection> {\n    const clientToken = await this.getClientToken(docId, authDocRequest)\n    return new DocConnection(clientToken)\n  }\n\n  /**\n   * Creates a new document with initial content.\n   *\n   * @param update A Yjs update byte string representing the initial content.\n   * @returns A {@link DocCreationResult} object containing the ID of the created document.\n   */\n  public async createDocWithContent(update: Uint8Array): Promise<DocCreationResult> {\n    const result = await this.createDoc()\n    await this.updateDoc(result.docId, update)\n    return result\n  }\n}\n\n/**\n * A convenience wrapper around {@link DocumentManager.getOrCreateDocAndToken} for getting or creating a document\n * with the given ID and returning a client token for accessing it.\n *\n * @param connectionString A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.\n * @param docId The ID of the document to get or create. If not provided, a new document with a random ID will be created.\n * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.\n * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n */\nexport async function getOrCreateDocAndToken(\n  connectionString: string,\n  docId?: string,\n  authDocRequest?: AuthDocRequest,\n): Promise<ClientToken> {\n  const manager = new DocumentManager(connectionString)\n  return await manager.getOrCreateDocAndToken(docId, authDocRequest)\n}\n\n/**\n * A convenience wrapper around {@link DocumentManager.getClientToken} for getting a client token for a document.\n *\n * @param connectionString A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.\n * @param docId The ID of the document to get a token for.\n * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.\n * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.\n */\nexport async function getClientToken(\n  connectionString: string,\n  docId: string | DocCreationResult,\n  authDocRequest?: AuthDocRequest,\n): Promise<ClientToken> {\n  const manager = new DocumentManager(connectionString)\n  return await manager.getClientToken(docId, authDocRequest)\n}\n\n/**\n * A convenience wrapper around {@link DocumentManager.createDoc} for creating a new document. If a document with the\n * given ID already exists, this is a no-op.\n *\n * @param connectionString A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.\n * @param docId The ID of the document to create. If not provided, a random ID will be generated.\n * @returns A {@link DocCreationResult} object containing the ID of the created document.\n */\nexport async function createDoc(\n  connectionString: string,\n  docId?: string,\n): Promise<DocCreationResult> {\n  const manager = new DocumentManager(connectionString)\n  return await manager.createDoc(docId)\n}\n"]}