"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/error.ts
var YSweetError = class _YSweetError extends Error {
  /**
   * Create a new {@link YSweetError}.
   *
   * @param cause An object representing metadata associated with the error.
   * @see {@link YSweetErrorPayload}
   */
  constructor(cause) {
    super(_YSweetError.getMessage(cause));
    this.cause = cause;
    this.name = "YSweetError";
  }
  /** Convert the message to an error string that can be displayed to the user.
   *
   * The error string can also be used with {@link YSweetError.fromMessage} to
   * reconstruct the payload object, which is useful in the context of Next.js,
   * which will only pass an error string from the server to the client.
   *
   * @param payload The payload object to convert to a string.
   * @returns A string representation of the error.
   */
  static getMessage(payload) {
    let message;
    if (payload.code === "ServerRefused") {
      message = `Server at ${payload.address}:${payload.port} refused connection. URL: ${payload.url}`;
    } else if (payload.code === "ServerError") {
      message = `Server responded with ${payload.status} ${payload.message}. URL: ${payload.url}`;
    } else if (payload.code === "NoAuthProvided") {
      message = "No auth provided";
    } else if (payload.code === "InvalidAuthProvided") {
      message = "Invalid auth provided";
    } else {
      message = payload.message;
    }
    return `${payload.code}: ${message}`;
  }
  /**
   * In development, next.js passes error objects to the client but strips out everything but the
   * `message` field. This method allows us to reconstruct the original error object.
   *
   * @param messageString The error message string to reconstruct a payload from.
   * @returns A {@link YSweetError} object.
   * @see {@link https://nextjs.org/docs/app/api-reference/file-conventions/error#errormessage| Next.js docs}
   */
  static fromMessage(messageString) {
    let match = messageString.match(/^(.*?): (.*)$/);
    if (!match) {
      return new _YSweetError({ code: "Unknown", message: messageString });
    }
    let [, code, message] = match;
    if (code === "ServerRefused") {
      match = message.match(/^Server at (.*?):(\d+) refused connection. URL: (.*)$/);
      if (!match) {
        return new _YSweetError({ code: "Unknown", message: messageString });
      }
      let [, address, port, url] = match;
      return new _YSweetError({ code, address, port: parseInt(port), url });
    }
    if (code === "ServerError") {
      match = message.match(/^Server responded with (\d+) (.*). URL: (.*)$/);
      if (!match) {
        return new _YSweetError({ code: "Unknown", message: messageString });
      }
      let [, status, statusText, url] = match;
      return new _YSweetError({ code, status: parseInt(status), message: statusText, url });
    }
    if (code === "NoAuthProvided") {
      return new _YSweetError({ code });
    }
    if (code === "InvalidAuthProvided") {
      return new _YSweetError({ code });
    }
    return new _YSweetError({ code: "Unknown", message });
  }
};

// src/http.ts
var HttpClient = class {
  constructor(baseUrl, token) {
    this.token = null;
    this.baseUrl = baseUrl;
    this.token = token;
  }
  async request(path, method, body) {
    const headers = new Headers();
    if (this.token) {
      headers.set("Authorization", `Bearer ${this.token}`);
    }
    let rawBody;
    if (body instanceof Uint8Array) {
      headers.set("Content-Type", "application/octet-stream");
      rawBody = body;
    } else if (body) {
      headers.set("Content-Type", "application/json");
      rawBody = JSON.stringify(body);
    }
    const cacheBust = generateRandomString();
    let url = `${this.baseUrl}/${path}?z=${cacheBust}`;
    let result;
    try {
      result = await fetch(url, {
        method,
        body: rawBody,
        headers
      });
    } catch (error) {
      if (_optionalChain([error, 'access', _ => _.cause, 'optionalAccess', _2 => _2.code]) === "ECONNREFUSED") {
        let { address, port } = error.cause;
        throw new YSweetError({ code: "ServerRefused", address, port, url });
      } else {
        throw new YSweetError({ code: "Unknown", message: error.toString() });
      }
    }
    if (!result.ok) {
      if (result.status === 401) {
        if (this.token) {
          throw new YSweetError({ code: "InvalidAuthProvided" });
        } else {
          throw new YSweetError({ code: "NoAuthProvided" });
        }
      }
      throw new YSweetError({
        code: "ServerError",
        status: result.status,
        message: result.statusText,
        url
      });
    }
    return result;
  }
};
function generateRandomString() {
  return Math.random().toString(36).substring(2);
}

// src/connection.ts
var DocConnection = class {
  constructor(clientToken) {
    let baseUrl = clientToken.baseUrl.replace(/\/$/, "");
    this.client = new HttpClient(baseUrl, _nullishCoalesce(clientToken.token, () => ( null)));
    this.docId = clientToken.docId;
  }
  /**
   * Returns an entire document, represented as a Yjs update byte string.
   *
   * This can be turned back into a Yjs document as follows:
   *
   * ```typescript
   * import * as Y from 'yjs'
   *
   * let update = await manager.getDocAsUpdate(docId)
   * let doc = new Y.Doc()
   * doc.transact(() => {
   *  Y.applyUpdate(doc, update)
   * })
   * ```
   *
   * @returns
   */
  async getAsUpdate() {
    const result = await this.client.request(`as-update`, "GET");
    if (!result.ok) {
      throw new Error(`Failed to get doc ${this.docId}: ${result.status} ${result.statusText}`);
    }
    let buffer = await result.arrayBuffer();
    return new Uint8Array(buffer);
  }
  /**
   * Updates a document with the given Yjs update byte string.
   *
   * This can be generated from a Yjs document as follows:
   *
   * ```typescript
   * import * as Y from 'yjs'
   *
   * let doc = new Y.Doc()
   * // Modify the document...
   * let update = Y.encodeStateAsUpdate(doc)
   * await manager.updateDoc(docId, update)
   * ```
   *
   * @param update
   */
  async updateDoc(update) {
    const result = await this.client.request(`update`, "POST", update);
    if (!result.ok) {
      throw new Error(`Failed to update doc ${this.docId}: ${result.status} ${result.statusText}`);
    }
  }
};

// src/encoding.ts
function stringToBase64(input) {
  if (typeof window !== "undefined" && window.btoa) {
    return window.btoa(input);
  } else if (typeof Buffer !== "undefined") {
    return Buffer.from(input).toString("base64");
  } else {
    throw new Error("Unable to encode to Base64");
  }
}
function base64ToString(input) {
  if (typeof window !== "undefined" && window.atob) {
    return window.atob(input);
  } else if (typeof Buffer !== "undefined") {
    return Buffer.from(input, "base64").toString();
  } else {
    throw new Error("Unable to decode from Base64");
  }
}
function encodeClientToken(token) {
  const jsonString = JSON.stringify(token);
  let base64 = stringToBase64(jsonString);
  base64 = base64.replace("+", "-").replace("/", "_").replace(/=+$/, "");
  return base64;
}
function decodeClientToken(token) {
  let base64 = token.replace("-", "+").replace("_", "/");
  while (base64.length % 4) {
    base64 += "=";
  }
  const jsonString = base64ToString(base64);
  return JSON.parse(jsonString);
}

// src/main.ts
var DocumentManager = class {
  /**
   * Create a new {@link DocumentManager}.
   *
   * @param serverToken A connection string (starting with `ys://` or `yss://`) referring to a y-sweet server.
   */
  constructor(connectionString) {
    const parsedUrl = new URL(connectionString);
    let token = null;
    if (parsedUrl.username) {
      token = decodeURIComponent(parsedUrl.username);
    }
    let protocol = parsedUrl.protocol;
    if (protocol === "ys:") {
      protocol = "http:";
    } else if (protocol === "yss:") {
      protocol = "https:";
    }
    const url = `${protocol}//${parsedUrl.host}${parsedUrl.pathname}`;
    let baseUrl = url.replace(/\/$/, "");
    this.client = new HttpClient(baseUrl, token);
  }
  async checkStore() {
    return await (await this.client.request("check_store", "POST", {})).json();
  }
  /**
   * Creates a new document on the y-sweet server given an optional docId. If a document with given
   * ID already exists, this is a no-op.
   *
   * @param docId The ID of the document to be created. If not provided, a random ID will be generated.
   * @returns A {@link DocCreationResult} object containing the ID of the created document.
   */
  async createDoc(docId) {
    const body = docId ? { docId } : {};
    const result = await this.client.request("doc/new", "POST", body);
    if (!result.ok) {
      throw new Error(`Failed to create doc: ${result.status} ${result.statusText}`);
    }
    const responseBody = await result.json();
    return responseBody;
  }
  /**
   * Get a client token for the given document.
   *
   * If you are using authorization, this is expected to be called from your server
   * after a user has authenticated. The returned token should then be passed to the
   * client.
   *
   * @param docId The ID of the document to get a token for.
   * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.
   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.
   */
  async getClientToken(docId, authDocRequest) {
    if (typeof docId !== "string") {
      docId = docId.docId;
    }
    const result = await this.client.request(`doc/${docId}/auth`, "POST", _nullishCoalesce(authDocRequest, () => ( {})));
    if (!result.ok) {
      throw new Error(`Failed to auth doc ${docId}: ${result.status} ${result.statusText}`);
    }
    const responseBody = await result.json();
    return responseBody;
  }
  /**
   * A convenience wrapper around {@link DocumentManager.createDoc} and {@link DocumentManager.getClientToken} for
   * getting a client token for a document. If a docId is provided, ensures that a document exists with that ID or
   * that one is created. If no docId is provided, a new document is created with a random ID.
   *
   * @param docId The ID of the document to get or create. If not provided, a new document with a random ID will be created.
   * @param authDocRequest An optional {@link AuthDocRequest} providing options for the token request.
   * @returns A {@link ClientToken} object containing the URL and token needed to connect to the document.
   */
  async getOrCreateDocAndToken(docId, authDocRequest) {
    const result = await this.createDoc(docId);
    return await this.getClientToken(result, authDocRequest);
  }
  /**
   * Returns an entire document, represented as a Yjs update byte string.
   *
   * @param docId The ID of the document to get.
   * @returns The document as a Yjs update byte string
   */
  async getDocAsUpdate(docId) {
    const connection = await this.getDocConnection(docId);
    return await connection.getAsUpdate();
  }
  /**
   * Updates a document with the given Yjs update byte string.
   *
   * @param docId The ID of the document to update.
   * @param update The Yjs update byte string to apply to the document.
   */
  async updateDoc(docId, update) {
    const connection = await this.getDocConnection(docId);
    return await connection.updateDoc(update);
  }
  async getDocConnection(docId, authDocRequest) {
    const clientToken = await this.getClientToken(docId, authDocRequest);
    return new DocConnection(clientToken);
  }
  /**
   * Creates a new document with initial content.
   *
   * @param update A Yjs update byte string representing the initial content.
   * @returns A {@link DocCreationResult} object containing the ID of the created document.
   */
  async createDocWithContent(update) {
    const result = await this.createDoc();
    await this.updateDoc(result.docId, update);
    return result;
  }
};
async function getOrCreateDocAndToken(connectionString, docId, authDocRequest) {
  const manager = new DocumentManager(connectionString);
  return await manager.getOrCreateDocAndToken(docId, authDocRequest);
}
async function getClientToken(connectionString, docId, authDocRequest) {
  const manager = new DocumentManager(connectionString);
  return await manager.getClientToken(docId, authDocRequest);
}
async function createDoc(connectionString, docId) {
  const manager = new DocumentManager(connectionString);
  return await manager.createDoc(docId);
}









exports.DocConnection = DocConnection; exports.DocumentManager = DocumentManager; exports.YSweetError = YSweetError; exports.createDoc = createDoc; exports.decodeClientToken = decodeClientToken; exports.encodeClientToken = encodeClientToken; exports.getClientToken = getClientToken; exports.getOrCreateDocAndToken = getOrCreateDocAndToken;
//# sourceMappingURL=main.js.map